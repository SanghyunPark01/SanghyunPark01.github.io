---
title:  "[2021-2-project] 7. Yolo 와 ROS 연동"
excerpt: "darknet_ros 패키지 사용과 video_stream_opencv 활용"

categories:
  - Basic_Autodrive_Software
tags:
  - [2021-2-project, ROS, Yolo]

toc: true
toc_sticky: true
 
date: 2021-11-06
last_modified_at: 2021-11-06
---  
# 1. darknet_ros   
darknet_ros는 Yolo와 ROS를 연동 시켜주는 ROS package이다.  
카메라를 통한 테스트 밖에 되지 않으므로, 동영상으로 테스트를 하고싶을 때는 다른 패키지를 이용하여야 한다.
# 2. darknet_ros 설치  
`git clone https://github.com/leggedrobotics/darknet_ros.git`  
darknet_ros 중에 다른 사람이 만든것도 있지만 나는 이걸로 설치하였다.
# 3. video_stream_opencv 설치  
앞서 말했듯, darknet_ros는 동영상 테스트가 불가능하다. 그래서 video_stream_opencv를 설치해 darknet_ros와 토픽 메시지를 연결해서 실행해주어야 한다.  
`video_stream_opencv/launch/video_file.launch`에서 `video_stream_provider`옆에 `value`값을 실행시키고 싶은 동영상 경로로 바꿔주어야한다.  
# 4. ROS  
video_stream_opencv로 동영상 실행시 `$ rostopic list`를 입력하면 동영상이 실행되고 전달되는 topic을 확인할 수 있다.  
토픽이름을 복사한다.  `darknet_ros/darknet_ros/config/ros.yaml`에 들어가서 `camera_reading : `부분에 `topic` 에 붙여넣기한다.  
각 launch파일을 실행해주고 오류가 없다면 성공이다. (동영상파일과, 동영상파일에서 기본 yolov3 모델 인식, 인식된 물체의 좌표값과 신뢰도)  

# 5. 문제점
실행시 rgb가 반전되서 나올 수 도 있다.  
`darknet_ros/darknet_ros/src/YoloObjectDetector.cpp`에 들어간다.  
164번째줄이다. (시간에 따라 코드 위치는 바뀔 수 있음)
```
try {
    if (msg->encoding == "mono8" || msg->encoding == "bgr8" || msg->encoding == "rgb8") {
      cam_image = cv_bridge::toCvCopy(msg, msg->encoding);
    } else if ( msg->encoding == "bgra8") {
      cam_image = cv_bridge::toCvCopy(msg, "bgr8");
    } else if ( msg->encoding == "rgba8") {
      cam_image = cv_bridge::toCvCopy(msg, "rgb8");
    } else if ( msg->encoding == "mono16") {
      ROS_WARN_ONCE("Converting mono16 images to mono8");
      cam_image = cv_bridge::toCvCopy(msg, "mono8");
    } else {
      ROS_ERROR("Image message encoding provided is not mono8, mono16, bgr8, bgra8, rgb8 or rgba8.");
    }
  } catch (cv_bridge::Exception& e) {
    ROS_ERROR("cv_bridge exception: %s", e.what());
    return;
  }
```  
여기에서 첫번째 if문을 수정해주면 된다. 첫번째 if문은 인코딩 값을 그대로 내보내는 조건문이다. 여기서 `cam_image = cv_bridge::toCvCopy(msg, msg->encoding);`을 `cam_image = cv_bridge::toCvCopy(msg, "rgb8");`로 바꿔주어서 무조건 rgb값으로 내보내게 만들면 문제가 해결이 된다.